# Analyses for Figure 3
  
## Simulating landscapes from known coefficients
  
The following function draws random coefficients for a Markov network of a pre-specified size.
The probability distribution was chosen so that most species pairs interact weakly, a few
act strongly, and that most of the interactions were negative rather than positive.

```{r, cache=TRUE}
make_coefficients = function(n_spp){
  # Exponential distribution has lots of mass near 0 but has
  # a long tail.
  true_beta_magnitudes = rexp(choose(n_spp, 2))
  
  # Species interactions are negative 3/4 of the time in 
  # these simulations.
  b = true_beta_magnitudes * sample(
    c(-1, 1), 
    size = length(true_beta_magnitudes), 
    prob = c(.75, .25),
    replace = TRUE
  )
  
  # Species' intercepts are normally distributed
  a = rnorm(n_spp, -1)
  
  
  # Return the simulated values.
  # The rosalia function stores pairwise parameters in the upper
  # triangle of an n-by-n matrix and stores the species intercepts
  # along the diagonal, so these values are named accordingly.
  c(alpha  = a, beta = b)
}
```


I used the following function to generate "true" parameters with the method above, 
simulate a presence-absence landscape based on those parameters using Markov chain Monte Carlo, and save the results to a "fakedata" folder.

I used Gibbs sampling as my Markov chain Monte Carlo transition operator.
In each round of Gibbs sampling, I cycled through all the species, randomly
updating each one's presence/absence vector in response to its conditional
occurrence probability:

$$p(y_i) = \mathrm{logistic}(\alpha_i + \sum_j\beta_{ij}y_j),$$

where the logistic function is $\frac{1}{1+e^{-x}}$.

```{r, cache = TRUE}
simulate_data = function(n_spp, n_sites, rep_name, n_gibbs = 1000, n_env = 2, sd = 2){
  
  # Determine the "true" parameters for the simulated assemblage
  par = make_coefficients(n_spp)
  
  # "True" interaction strengths, to save for later
  truth = par[-(1:n_spp)]
  
  # "True" intercepts, possibly adjusted below by environment
  alpha = par[1:n_spp]
  

    
  # Turn the interaction values into an n-by-n matrix
  # Start with empty matrix; fill in upper triangle; 
  # then fill in lower triangle with its transpose
  beta = matrix(0, n_spp, n_spp)
  beta[upper.tri(beta)] = truth
  beta = beta + t(beta)
  
  # Environmental states are normally distributed
  env = matrix(rnorm(n_sites * n_env), ncol = n_env)
  
  alpha_env = matrix(rnorm(n_spp * n_env, sd = sd), nrow = n_env)
  
  
  
  
  
  # Simulate the landscape from known process with Gibbs sampling
  
  
  # Landscape starts as if betas were all zero. Each species' occurrence probability
  # depends on its alpha value and on the environment (assuming alpha_env is not zero).
  x = matrix(
    plogis(rep(1, n_sites) %*% t(alpha) + env %*% alpha_env), 
    nrow = n_sites, 
    ncol = n_spp
  )
  
  # Gibbs sampling
  for(i in 1:n_gibbs){
    
    # Each round of Gibbs sampling updates one species (column) across all sites
    # according to its conditional probability (i.e. conditional on environment
    # and the other species that are present).
    for(j in 1:n_spp){
      x[,j] = rbinom(
        nrow(x),
        size = 1,
        prob = plogis(x %*% beta[ , j] + alpha[j] + env %*% alpha_env[,j])
      )
    }
  }
  
  
  # Save the results in a "fake data" folder
  
  file_stem = paste(n_spp, n_sites, rep_name, sep = "-")
  
  # Save the matrix of presence/absence observations
  write.csv(
    x, 
    file = paste0("fakedata/matrices/", file_stem, ".csv")
  )
  
  # Gotelli and Ulrich's Pairs software rejects empty sites, so I remove them here
  x_subset = x[rowSums(x) != 0, colSums(x) != 0]
  
  # Gotelli and Ulrich's Pairs method expects the data matrices to be transposed,
  # So I save them separately
  write.table(
    t(x_subset), 
    file = paste0("fakedata/matrices/", file_stem, "-transposed.txt"), 
    quote = FALSE
  )
  
  # Save the "true" species interactions
  write(
    truth, 
    file = paste0("fakedata/truths/", file_stem, ".txt"), 
    ncolumns = length(truth)
  )
}
```


```{r}
set.seed(1)
n_spp = 20

for(n_sites in c(25, 200, 1600)){
  for(type in c("env", "no_env")){
    for(i in 1:50){
      simulate_data(
        n_spp = n_spp, 
        n_sites = n_sites, 
        rep_name = paste0(type, i),
        sd = ifelse(type == "env", 2, 0)
      )
    }
  }
}

```

